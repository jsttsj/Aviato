landcolor = toRGB("gray85"),
subunitwidth = 1,
countrywidth = 1,
subunitcolor = toRGB("white"),
countrycolor = toRGB("white")
)
# Plot the bubble map on Plotly
p <- plot_geo(to.plot, locationmode = 'USA-states', sizes = c(1, 150), color=~ranking) %>%
# Specifications of the bubble markers.
add_markers(
x = ~lon, y = ~lat, hoverinfo = "text", size = ~ranking,
text = ~paste(to.plot$new.name, "<br />", to.plot$related.topic, "<br />", "#", 21 - to.plot$ranking)
) %>%
layout(title = 'Trending levels of topics', geo = g)
# Obtain a dataframe of data that will be rendered on the map of the US.
to.plot <- getData()
# Specifications of the appearance of the map.
g <- list(
scope = 'usa',
projection = list(type = 'albers usa'),
showland = TRUE,
landcolor = toRGB("gray85"),
subunitwidth = 1,
countrywidth = 1,
subunitcolor = toRGB("white"),
countrycolor = toRGB("white")
)
# Plot the bubble map on Plotly
p <- plot_geo(to.plot, locationmode = 'USA-states', sizes = c(1, 150), color=~ranking) %>%
# Specifications of the bubble markers.
add_markers(
x = ~lon, y = ~lat, hoverinfo = "text", size = ~ranking,
text = ~paste(to.plot$new.name, "<br />", to.plot$related.topic, "<br />", "#", 21 - to.plot$ranking)
) %>%
layout(title = 'Trending levels of topics', geo = g)
getData <- function() {
# Obtain a vector of all city names so it is easier to traverse through the matrix.
all.cities <- rownames(city.data)
# Create vectors for topic ranking and the corresponding related topics based on the
# search string so that they can be added to the plotted data frame later.
ranking <- vector(mode="integer", length = length(all.cities))
related.topic <- vector(mode="character", length = length(all.cities))
# Consolidate the the information into that will be displayed to the user into
# a single dataframe
for(city in 1:5) { #length(all.cities)
# Obtain information on the popular topics in a given city.
current.city <- all.cities[city]
most.popular <- city.data[[current.city, 1]]
# Conditions to control the while loop
has.match <- FALSE
index <- 1
# Given the list of popular
while(has.match == FALSE && index < 6) {#length(all.cities) + 1
# Initialize dummy values to be placed in the data frame.
put.related.topic <- ""
put.ranking <- NA
popular.topic <- most.popular[[index]]$name
# Check if the search string is related to a popular topic in the city.
# If there is a popular topic, update the dummy values initialized earlier.
if(grepl(search.string, tolower(gsub(" ", "", popular.topic))) == TRUE) {
put.related.topic <- popular.topic
put.ranking <- index
has.match <- TRUE
}
# Record the values into the data frame.
ranking[city] <- put.ranking
related.topic[city] <- put.related.topic
# Continue traversing the matrix.
index <- index + 1
}
}
# Return a new data frame containing city name with geographical location and the
# name and popularity of the matched topic.
return(cities %>%
select(new.name, lat, lon) %>%
mutate(ranking, related.topic))
}
# Obtain a dataframe of data that will be rendered on the map of the US.
to.plot <- getData()
# Specifications of the appearance of the map.
g <- list(
scope = 'usa',
projection = list(type = 'albers usa'),
showland = TRUE,
landcolor = toRGB("gray85"),
subunitwidth = 1,
countrywidth = 1,
subunitcolor = toRGB("white"),
countrycolor = toRGB("white")
)
# Plot the bubble map on Plotly
p <- plot_geo(to.plot, locationmode = 'USA-states', sizes = c(1, 150), color=~ranking) %>%
# Specifications of the bubble markers.
add_markers(
x = ~lon, y = ~lat, hoverinfo = "text", size = ~ranking,
text = ~paste(to.plot$new.name, "<br />", to.plot$related.topic, "<br />", "#", 21 - to.plot$ranking)
) %>%
layout(title = 'Trending levels of topics', geo = g)
p
View(to.plot)
runApp()
getData <- function() {
# Obtain a vector of all city names so it is easier to traverse through the matrix.
all.cities <- rownames(city.data)
# Create vectors for topic ranking and the corresponding related topics based on the
# search string so that they can be added to the plotted data frame later.
ranking <- vector(mode="integer", length = length(all.cities))
related.topic <- vector(mode="character", length = length(all.cities))
# Consolidate the the information into that will be displayed to the user into
# a single dataframe
for(city in 1:5) { #length(all.cities)
# Obtain information on the popular topics in a given city.
current.city <- all.cities[city]
most.popular <- city.data[[current.city, 1]]
# Conditions to control the while loop
has.match <- FALSE
index <- 1
# Given the list of popular
while(has.match == FALSE && index < 6) {#length(all.cities) + 1
# Initialize dummy values to be placed in the data frame.
put.related.topic <- ""
put.ranking <- NA
popular.topic <- most.popular[[index]]$name
# Check if the search string is related to a popular topic in the city.
# If there is a popular topic, update the dummy values initialized earlier.
if(grepl(searchString(), tolower(gsub(" ", "", popular.topic))) == TRUE) {
put.related.topic <- popular.topic
put.ranking <- index
has.match <- TRUE
}
# Record the values into the data frame.
ranking[city] <- put.ranking
related.topic[city] <- put.related.topic
# Continue traversing the matrix.
index <- index + 1
}
}
# Return a new data frame containing city name with geographical location and the
# name and popularity of the matched topic.
return(cities %>%
select(new.name, lat, lon) %>%
mutate(ranking, related.topic) %>%
filter(ranking != NA))
}
to.plot <- getData()
# Specifications of the appearance of the map.
g <- list(
scope = 'usa',
projection = list(type = 'albers usa'),
showland = TRUE,
landcolor = toRGB("gray85"),
subunitwidth = 1,
countrywidth = 1,
subunitcolor = toRGB("white"),
countrycolor = toRGB("white")
)
# Plot the bubble map on Plotly
p <- plot_geo(to.plot, locationmode = 'USA-states', sizes = c(1, 150), color=~ranking) %>%
# Specifications of the bubble markers.
add_markers(
x = ~lon, y = ~lat, hoverinfo = "text", size = ~ranking,
text = ~paste(to.plot$new.name, "<br />", to.plot$related.topic, "<br />", "#", to.plot$ranking)
) %>%
layout(title = 'Trending levels of topics', geo = g) %>%
return()
})
to.plot <- getData()
# Specifications of the appearance of the map.
g <- list(
scope = 'usa',
projection = list(type = 'albers usa'),
showland = TRUE,
landcolor = toRGB("gray85"),
subunitwidth = 1,
countrywidth = 1,
subunitcolor = toRGB("white"),
countrycolor = toRGB("white")
)
# Plot the bubble map on Plotly
p <- plot_geo(to.plot, locationmode = 'USA-states', sizes = c(1, 150), color=~ranking) %>%
# Specifications of the bubble markers.
add_markers(
x = ~lon, y = ~lat, hoverinfo = "text", size = ~ranking,
text = ~paste(to.plot$new.name, "<br />", to.plot$related.topic, "<br />", "#", to.plot$ranking)
) %>%
layout(title = 'Trending levels of topics', geo = g) %>%
return()
})
# Obtain a dataframe of data that will be rendered on the map of the US.
to.plot <- getData()
# Specifications of the appearance of the map.
g <- list(
scope = 'usa',
projection = list(type = 'albers usa'),
showland = TRUE,
landcolor = toRGB("gray85"),
subunitwidth = 1,
countrywidth = 1,
subunitcolor = toRGB("white"),
countrycolor = toRGB("white")
)
# Plot the bubble map on Plotly
p <- plot_geo(to.plot, locationmode = 'USA-states', sizes = c(1, 150), color=~ranking) %>%
# Specifications of the bubble markers.
add_markers(
x = ~lon, y = ~lat, hoverinfo = "text", size = ~ranking,
text = ~paste(to.plot$new.name, "<br />", to.plot$related.topic, "<br />", "#", to.plot$ranking)
) %>%
layout(title = 'Trending levels of topics', geo = g) %>%
return()
})
to.plot <- getData()
# Specifications of the appearance of the map.
g <- list(
scope = 'usa',
projection = list(type = 'albers usa'),
showland = TRUE,
landcolor = toRGB("gray85"),
subunitwidth = 1,
countrywidth = 1,
subunitcolor = toRGB("white"),
countrycolor = toRGB("white")
)
# Plot the bubble map on Plotly
p <- plot_geo(to.plot, locationmode = 'USA-states', sizes = c(1, 150), color=~ranking) %>%
# Specifications of the bubble markers.
add_markers(
x = ~lon, y = ~lat, hoverinfo = "text", size = ~ranking,
text = ~paste(to.plot$new.name, "<br />", to.plot$related.topic, "<br />", "#", to.plot$ranking)
) %>%
layout(title = 'Trending levels of topics', geo = g)
View(to.plot)
to.plot <- getData()
# Obtain a dataframe of data that will be rendered on the map of the US.
to.plot <- getData()
# Specifications of the appearance of the map.
g <- list(
scope = 'usa',
projection = list(type = 'albers usa'),
showland = TRUE,
landcolor = toRGB("gray85"),
subunitwidth = 1,
countrywidth = 1,
subunitcolor = toRGB("white"),
countrycolor = toRGB("white")
)
# Plot the bubble map on Plotly
p <- plot_geo(to.plot, locationmode = 'USA-states', sizes = c(1, 150), color=~ranking) %>%
# Specifications of the bubble markers.
add_markers(
x = ~lon, y = ~lat, hoverinfo = "text", size = ~ranking,
text = ~paste(to.plot$new.name, "<br />", to.plot$related.topic, "<br />", "#", to.plot$ranking)
) %>%
layout(title = 'Trending levels of topics', geo = g) %>%
return()
})
getData <- function() {
# Obtain a vector of all city names so it is easier to traverse through the matrix.
all.cities <- rownames(city.data)
# Create vectors for topic ranking and the corresponding related topics based on the
# search string so that they can be added to the plotted data frame later.
ranking <- vector(mode="integer", length = length(all.cities))
related.topic <- vector(mode="character", length = length(all.cities))
# Consolidate the the information into that will be displayed to the user into
# a single dataframe
for(city in 1:5) { #length(all.cities)
# Obtain information on the popular topics in a given city.
current.city <- all.cities[city]
most.popular <- city.data[[current.city, 1]]
# Conditions to control the while loop
has.match <- FALSE
index <- 1
# Given the list of popular
while(has.match == FALSE && index < 6) {#length(all.cities) + 1
# Initialize dummy values to be placed in the data frame.
put.related.topic <- ""
put.ranking <- NA
popular.topic <- most.popular[[index]]$name
# Check if the search string is related to a popular topic in the city.
# If there is a popular topic, update the dummy values initialized earlier.
if(grepl(search.string, tolower(gsub(" ", "", popular.topic))) == TRUE) {
put.related.topic <- popular.topic
put.ranking <- index
has.match <- TRUE
}
# Record the values into the data frame.
ranking[city] <- put.ranking
related.topic[city] <- put.related.topic
# Continue traversing the matrix.
index <- index + 1
}
}
# Return a new data frame containing city name with geographical location and the
# name and popularity of the matched topic.
return(cities %>%
select(new.name, lat, lon) %>%
mutate(ranking, related.topic) %>%
filter(ranking != NA))
}
to.plot <- getData()
View(to.plot)
cities %>% select(new.name, late, lon) %>% mutate(ranking, related.topic) %>% filter(ranking != NA)
cities %>% select(new.name, lat, lon) %>% mutate(ranking, related.topic)
ranking
related.topic
getData <- function() {
# Obtain a vector of all city names so it is easier to traverse through the matrix.
all.cities <- rownames(city.data)
# Create vectors for topic ranking and the corresponding related topics based on the
# search string so that they can be added to the plotted data frame later.
ranking <- vector(mode="integer", length = length(all.cities))
related.topic <- vector(mode="character", length = length(all.cities))
# Consolidate the the information into that will be displayed to the user into
# a single dataframe
for(city in 1:5) { #length(all.cities)
# Obtain information on the popular topics in a given city.
current.city <- all.cities[city]
most.popular <- city.data[[current.city, 1]]
# Conditions to control the while loop
has.match <- FALSE
index <- 1
# Given the list of popular
while(has.match == FALSE && index < 6) {#length(all.cities) + 1
# Initialize dummy values to be placed in the data frame.
put.related.topic <- ""
put.ranking <- NA
popular.topic <- most.popular[[index]]$name
# Check if the search string is related to a popular topic in the city.
# If there is a popular topic, update the dummy values initialized earlier.
if(grepl(searchString(), tolower(gsub(" ", "", popular.topic))) == TRUE) {
put.related.topic <- popular.topic
put.ranking <- index
has.match <- TRUE
}
# Record the values into the data frame.
ranking[city] <- put.ranking
related.topic[city] <- put.related.topic
# Continue traversing the matrix.
index <- index + 1
}
}
# Return a new data frame containing city name with geographical location and the
# name and popularity of the matched topic.
return(cities %>%
select(new.name, lat, lon) %>%
mutate(ranking, related.topic))
}
to.plot <- getData()
getData <- function() {
# Obtain a vector of all city names so it is easier to traverse through the matrix.
all.cities <- rownames(city.data)
# Create vectors for topic ranking and the corresponding related topics based on the
# search string so that they can be added to the plotted data frame later.
ranking <- vector(mode="integer", length = length(all.cities))
related.topic <- vector(mode="character", length = length(all.cities))
# Consolidate the the information into that will be displayed to the user into
# a single dataframe
for(city in 1:5) { #length(all.cities)
# Obtain information on the popular topics in a given city.
current.city <- all.cities[city]
most.popular <- city.data[[current.city, 1]]
# Conditions to control the while loop
has.match <- FALSE
index <- 1
# Given the list of popular
while(has.match == FALSE && index < 6) {#length(all.cities) + 1
# Initialize dummy values to be placed in the data frame.
put.related.topic <- ""
put.ranking <- NA
popular.topic <- most.popular[[index]]$name
# Check if the search string is related to a popular topic in the city.
# If there is a popular topic, update the dummy values initialized earlier.
if(grepl(search.string, tolower(gsub(" ", "", popular.topic))) == TRUE) {
put.related.topic <- popular.topic
put.ranking <- index
has.match <- TRUE
}
# Record the values into the data frame.
ranking[city] <- put.ranking
related.topic[city] <- put.related.topic
# Continue traversing the matrix.
index <- index + 1
}
}
# Return a new data frame containing city name with geographical location and the
# name and popularity of the matched topic.
return(cities %>%
select(new.name, lat, lon) %>%
mutate(ranking, related.topic))
}
to.plot <- getData()
View(to.plot)
View(to.plot %>% filter(ranking != NA))
View(to.plot %>% filter(ranking == NA))
NA == NA
NA===NA
is.na(NA)
View(to.plot %>% filter(is.na(ranking)))
runApp()
runApp()
list(unlist(locations.US$name), c("Data"))[1:5]
dimnames(city.data) <- list(unlist(locations.US$name), c("Data"))
runApp()
search.string
getData <- function() {
# Obtain a vector of all city names so it is easier to traverse through the matrix.
all.cities <- rownames(city.data)
# Create vectors for topic ranking and the corresponding related topics based on the
# search string so that they can be added to the plotted data frame later.
ranking <- vector(mode="integer", length = length(all.cities))
related.topic <- vector(mode="character", length = length(all.cities))
# Consolidate the the information into that will be displayed to the user into
# a single dataframe
for(city in 1:5) { #length(all.cities)
# Obtain information on the popular topics in a given city.
current.city <- all.cities[city]
most.popular <- city.data[[current.city, 1]]
# Conditions to control the while loop
has.match <- FALSE
index <- 1
# Given the list of popular
while(has.match == FALSE && index < 6) {#length(all.cities) + 1
# Initialize dummy values to be placed in the data frame.
put.related.topic <- ""
put.ranking <- NA
popular.topic <- most.popular[[index]]$name
# Check if the search string is related to a popular topic in the city.
# If there is a popular topic, update the dummy values initialized earlier.
if(grepl(search.string, tolower(gsub(" ", "", popular.topic))) == TRUE) {
put.related.topic <- popular.topic
put.ranking <- index
has.match <- TRUE
}
# Record the values into the data frame.
ranking[city] <- put.ranking
related.topic[city] <- put.related.topic
# Continue traversing the matrix.
index <- index + 1
}
}
# Return a new data frame containing city name with geographical location and the
# name and popularity of the matched topic.
return(cities %>%
select(new.name, lat, lon) %>%
mutate(ranking, related.topic) %>%
filter(is.na(ranking)))
}
to.plot <- getData()
View(to.plot)
getData <- function() {
# Obtain a vector of all city names so it is easier to traverse through the matrix.
all.cities <- rownames(city.data)
# Create vectors for topic ranking and the corresponding related topics based on the
# search string so that they can be added to the plotted data frame later.
ranking <- vector(mode="integer", length = length(all.cities))
related.topic <- vector(mode="character", length = length(all.cities))
# Consolidate the the information into that will be displayed to the user into
# a single dataframe
for(city in 1:5) { #length(all.cities)
# Obtain information on the popular topics in a given city.
current.city <- all.cities[city]
most.popular <- city.data[[current.city, 1]]
# Conditions to control the while loop
has.match <- FALSE
index <- 1
# Given the list of popular
while(has.match == FALSE && index < 6) {#length(all.cities) + 1
# Initialize dummy values to be placed in the data frame.
put.related.topic <- ""
put.ranking <- NA
popular.topic <- most.popular[[index]]$name
# Check if the search string is related to a popular topic in the city.
# If there is a popular topic, update the dummy values initialized earlier.
if(grepl(search.string, tolower(gsub(" ", "", popular.topic))) == TRUE) {
put.related.topic <- popular.topic
put.ranking <- index
has.match <- TRUE
}
# Record the values into the data frame.
ranking[city] <- put.ranking
related.topic[city] <- put.related.topic
# Continue traversing the matrix.
index <- index + 1
}
}
# Return a new data frame containing city name with geographical location and the
# name and popularity of the matched topic.
return(cities %>%
select(new.name, lat, lon) %>%
mutate(ranking, related.topic) %>%
filter(!is.na(ranking)))
}
to.plot <- getData()
View(to.plot)
runApp()
runApp()
runApp()
View(state.data.Richmond)
View(locations.US)
View(locations.US)
View(state.data.Albuquerque)
View(state.data.Albuquerque)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
